<body>

<script>

function make2DArray(cols, rows) {
  let arr = new Array(cols);
  for (let i = 0; i < arr.length; i++) {
    arr[i] = new Array(rows);
    for (let j = 0; j < arr[i].length; j++) {
      arr[i][j] = 0;
    }
  }
  return arr;
}

function isSand(state) {
  return state > 0 && state != 1;
}

function isVisibleHeart(state) {
  return state === heartHue;
}

function isSolid(state) {
  return isSand(state) || isVisibleHeart(state);
}

function isHiddenHeart(state) {
  return state === -1;
}

// The grid
let grid;
let w = 5;
let cols, rows;
let heartHue = 1;
let canvas;
let mouseIsPressed = false;
let dirty = false;

const mousePosText = document.getElementById('mouse-pos');
let mousePos = { x: undefined, y: undefined };

window.addEventListener('mousemove', (event) => {
  var rect = canvas.getBoundingClientRect();
  mousePos = { x: event.clientX - rect.left, y: event.clientY - rect.top };
});

// Check if a row is within the bounds
function withinCols(i) {
  return i >= 0 && i <= cols - 1;
}

// Check if a column is within the bounds
function withinRows(j) {
  return j >= 0 && j <= rows - 1;
}

function SetHue(i, j, h) {
  dirty = true;
  grid[i][j] = h;
}

function setup() {
  const canvasW = 800;
  const canvasH = 800;
  canvas = document.createElement('canvas');
  canvas.width = canvasW;
  canvas.height = canvasH;
  canvas.style.position = 'absolute';
  canvas.style.border = '1px solid';
  document.body.appendChild(canvas);
  cols = canvasW / w;
  rows = canvasH / w;
  grid = make2DArray(cols, rows);

  for (let t = 0; t < 2 * Math.PI; t += 0.015) {
    let sint = Math.sin(t);
    let x0 = 16 * sint * sint * sint;
    let y0 =
      -13 * Math.cos(t) +
      5 * Math.cos(2 * t) +
      2 * Math.cos(3 * t) +
      Math.cos(4 * t);
    let x = 0.5 * cols + Math.round(cols * x0 * 0.025);
    let y = 0.5 * rows + Math.round(rows * y0 * 0.025);
    grid[x][y] = -1;
  }

  document.addEventListener('mousedown', (event) => {
    if (event.button == 0) {
      mouseIsPressed = true;
      event.preventDefault(); // Prevent selection
      if (!dirty)
        requestAnimationFrame(draw);
    }
  });

  document.addEventListener('mouseup', (event) => {
    if (event.button == 0) {
      mouseIsPressed = false;
      event.preventDefault(); // Prevent selection
    }
  });
}

function draw() {
  dirty = false;

  const context = canvas.getContext('2d');
  context.rect(0, 0, canvas.width, canvas.height);
  context.fillStyle = "black";
  context.fill();

  if (mouseIsPressed) {
    let mouseCol = Math.floor(mousePos.x / w);
    let mouseRow = Math.floor(mousePos.y / w);

    if (withinCols(mouseCol) && withinRows(mouseRow)) {
      let state = grid[mouseCol][mouseRow];
      if (!isSolid(state) && !isHiddenHeart(state))
	SetHue(mouseCol, mouseRow, 30 + 40*Math.random());
    }
  }

  // Draw the sand
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      if (grid[i][j] > 0) {
        let x = i * w;
        let y = j * w;
        context.fillStyle = "hsl(" + grid[i][j] + ",100% , 50%)";
        context.fillRect(x, y, w, w);
      }
    }
  }

  // Create a 2D array for the next frame of animation
  let nextGrid = grid;

  // Check every cell
  for (let i = 0; i < cols; i++) {
    for (let j = rows - 1; j >= 0; j--) {
      // What is the state?
      let state = grid[i][j];

      if (isHiddenHeart(state)) {
        for (const el of [i + 1, i - 1]) {
          if (withinCols(el) && isSand(grid[el][j]))
            SetHue(i, j, heartHue);
        }
        for (const el of [j + 1, j - 1]) {
          if (isSand(grid[i][el])) {
	    SetHue(i, j, heartHue);
          }
        }
      }

      // If it's a piece of sand!
      if (isSand(state)) {
        // What is below?
        let below = grid[i][j + 1];

        // Randomly fall left or right
        let dir = 1;
        if (Math.random() < 0.5) {
          dir *= -1;
        }

        // Check below left or right
        let belowA = -1;
        let belowB = -1;
        if (withinCols(i + dir)) {
          belowA = grid[i + dir][j + 1];
        }
        if (withinCols(i - dir)) {
          belowB = grid[i - dir][j + 1];
        }

        // Can it fall below or left or right?
        if (below === 0) {
          nextGrid[i][j + 1] = state;
          nextGrid[i][j] = 0;
          dirty = true;
        } else if (belowA === 0 && !isSolid(grid[i + dir][j])) {
          nextGrid[i + dir][j + 1] = state;
          nextGrid[i][j] = 0;
          dirty = true;
        } else if (belowB === 0 && !isSolid(grid[i - dir][j])) {
          nextGrid[i - dir][j + 1] = state;
          nextGrid[i][j] = 0;
          dirty = true;
        } else {
          nextGrid[i][j] = state;
        }
      }
    }
  }
  grid = nextGrid;

  if (dirty)
    requestAnimationFrame(draw);
}

setup();
draw();

</script>
</body>